<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>InputManager Architecture - Conductor Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Multi-protocol input automation for MIDI controllers, game controllers, and custom hardware">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Conductor Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/amiable-dev/conductor" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/amiable-dev/conductor/edit/main/docs-site/src/src/development/input-manager-architecture.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="inputmanager-architecture"><a class="header" href="#inputmanager-architecture">InputManager Architecture</a></h1>
<p><strong>Version</strong>: 3.0
<strong>Status</strong>: Stable
<strong>Module</strong>: <code>conductor-daemon/src/input_manager.rs</code></p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The <strong>InputManager</strong> is Conductor's unified input handling system introduced in v3.0. It provides a single, cohesive interface for managing both MIDI and HID (game controller) input devices, producing a unified stream of protocol-agnostic <code>InputEvent</code> instances for processing by the mapping engine.</p>
<h3 id="key-features"><a class="header" href="#key-features">Key Features</a></h3>
<ul>
<li><strong>Multi-Protocol Support</strong>: Seamlessly integrates MIDI and HID game controller inputs</li>
<li><strong>Unified Event Stream</strong>: Single <code>InputEvent</code> channel for all input types</li>
<li><strong>Flexible Device Selection</strong>: Choose MIDI-only, gamepad-only, or hybrid (both) modes</li>
<li><strong>ID Range Separation</strong>: Non-overlapping ID ranges prevent conflicts (MIDI: 0-127, HID: 128-255)</li>
<li><strong>Automatic Reconnection</strong>: Inherits robust reconnection logic from device managers</li>
<li><strong>Thread Safety</strong>: Arc/Mutex patterns for safe concurrent access</li>
</ul>
<h2 id="architecture-diagram"><a class="header" href="#architecture-diagram">Architecture Diagram</a></h2>
<pre><code>┌────────────────────────────────────────────────────────────────────┐
│  InputManager (Unified Input Layer)                               │
│  ┌──────────────────────────────────────────────────────────────┐ │
│  │  InputMode Selection                                         │ │
│  │  - MidiOnly: MIDI device only                                │ │
│  │  - GamepadOnly: Game controller only                         │ │
│  │  - Both: MIDI + Gamepad simultaneously (hybrid mode)         │ │
│  └──────────────────────────────────────────────────────────────┘ │
│                                                                    │
│  ┌───────────────────────┐        ┌──────────────────────────┐   │
│  │  MidiDeviceManager    │        │  GamepadDeviceManager    │   │
│  │  (midir)              │        │  (gilrs v0.10)           │   │
│  │                       │        │                          │   │
│  │  - MIDI I/O           │        │  - HID event polling     │   │
│  │  - Port management    │        │  - SDL2 mappings         │   │
│  │  - Auto-reconnect     │        │  - Device enumeration    │   │
│  └──────────┬────────────┘        └────────────┬─────────────┘   │
│             │                                   │                 │
│             │ MidiEvent                         │ gilrs::Event    │
│             │                                   │                 │
│             ▼                                   ▼                 │
│  ┌──────────────────────┐          ┌──────────────────────────┐  │
│  │  MIDI → InputEvent   │          │  HID → InputEvent        │  │
│  │  Converter           │          │  Converter               │  │
│  │  (convert_midi)      │          │  (gamepad_events)        │  │
│  └──────────┬───────────┘          └────────────┬─────────────┘  │
│             │                                   │                 │
│             └───────────────┬───────────────────┘                 │
│                             ▼                                     │
│                  ┌───────────────────────┐                        │
│                  │  Unified InputEvent   │                        │
│                  │  Stream (mpsc)        │                        │
│                  └───────────┬───────────┘                        │
└──────────────────────────────┼────────────────────────────────────┘
                               │
                               ▼
                    ┌────────────────────────┐
                    │  EventProcessor        │
                    │  (conductor-core)        │
                    │                        │
                    │  - Velocity detection  │
                    │  - Long press          │
                    │  - Double-tap          │
                    │  - Chord detection     │
                    └────────┬───────────────┘
                             │
                             ▼
                    ┌────────────────────────┐
                    │  MappingEngine         │
                    │  (conductor-core)        │
                    │                        │
                    │  - Trigger matching    │
                    │  - Action execution    │
                    └────────────────────────┘
</code></pre>
<h2 id="inputmode-enum"><a class="header" href="#inputmode-enum">InputMode Enum</a></h2>
<p>The <code>InputMode</code> enum controls which input devices are active:</p>
<pre><code class="language-rust">pub enum InputMode {
    /// Use MIDI device only
    MidiOnly,

    /// Use gamepad device only
    GamepadOnly,

    /// Use both MIDI and gamepad simultaneously (hybrid mode)
    Both,
}</code></pre>
<h3 id="mode-selection-strategy"><a class="header" href="#mode-selection-strategy">Mode Selection Strategy</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Mode</th><th>MIDI Manager</th><th>Gamepad Manager</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>MidiOnly</code></td><td>✅ Active</td><td>❌ Disabled</td><td>Traditional MIDI controller workflows</td></tr>
<tr><td><code>GamepadOnly</code></td><td>❌ Disabled</td><td>✅ Active</td><td>Game controller macro setups</td></tr>
<tr><td><code>Both</code></td><td>✅ Active</td><td>✅ Active</td><td>Hybrid workflows (MIDI + gamepad)</td></tr>
</tbody></table>
</div>
<h2 id="id-range-separation"><a class="header" href="#id-range-separation">ID Range Separation</a></h2>
<p>To prevent conflicts between MIDI and HID inputs, Conductor uses non-overlapping ID ranges:</p>
<h3 id="midi-id-range-0-127"><a class="header" href="#midi-id-range-0-127">MIDI ID Range (0-127)</a></h3>
<p>MIDI protocol uses 7-bit addressing for notes and control changes:</p>
<ul>
<li><strong>Notes</strong>: 0-127 (C-2 to G8)</li>
<li><strong>Control Changes</strong>: 0-127 (CC0 to CC127)</li>
<li><strong>Velocity</strong>: 0-127 (off to maximum)</li>
</ul>
<p><strong>Example</strong>: MIDI note 60 (Middle C) → <code>InputEvent::PadPressed { pad: 60, ... }</code></p>
<h3 id="hid-id-range-128-255"><a class="header" href="#hid-id-range-128-255">HID ID Range (128-255)</a></h3>
<p>Game controller buttons and axes use IDs starting at 128:</p>
<h4 id="button-ids-128-144"><a class="header" href="#button-ids-128-144">Button IDs (128-144)</a></h4>
<pre><code>Face Buttons:
  128 = South (A/Cross/B)
  129 = East (B/Circle/A)
  130 = West (X/Square/Y)
  131 = North (Y/Triangle/X)

D-Pad:
  132 = Up
  133 = Down
  134 = Left
  135 = Right

Shoulder Buttons:
  136 = Left Shoulder (L1/LB)
  137 = Right Shoulder (R1/RB)

Stick Clicks:
  138 = Left Thumb (L3)
  139 = Right Thumb (R3)

Menu Buttons:
  140 = Start (Options/+)
  141 = Select (Share/-)
  142 = Guide (Xbox/PS/Home)

Trigger Digital:
  143 = Left Trigger (L2/LT)
  144 = Right Trigger (R2/RT)
</code></pre>
<h4 id="encoder-ids-128-133"><a class="header" href="#encoder-ids-128-133">Encoder IDs (128-133)</a></h4>
<p>Analog stick axes and triggers use encoder IDs:</p>
<pre><code>Analog Sticks:
  128 = Left Stick X
  129 = Left Stick Y
  130 = Right Stick X
  131 = Right Stick Y

Trigger Analog:
  132 = Left Trigger (L2/LT)
  133 = Right Trigger (R2/RT)
</code></pre>
<h3 id="why-non-overlapping-ranges"><a class="header" href="#why-non-overlapping-ranges">Why Non-Overlapping Ranges?</a></h3>
<ol>
<li><strong>Conflict Prevention</strong>: MIDI note 60 and gamepad button never collide</li>
<li><strong>Unified Processing</strong>: EventProcessor handles both identically</li>
<li><strong>Simple Disambiguation</strong>: Check ID range to determine source protocol</li>
<li><strong>Future Expansion</strong>: Room for additional input types (256-65535)</li>
</ol>
<h2 id="device-management"><a class="header" href="#device-management">Device Management</a></h2>
<h3 id="mididevicemanager"><a class="header" href="#mididevicemanager">MidiDeviceManager</a></h3>
<p><strong>Location</strong>: <code>conductor-daemon/src/midi_device.rs</code></p>
<p>Responsibilities:</p>
<ul>
<li>Connect to MIDI input ports via <code>midir</code></li>
<li>Emit <code>MidiEvent</code> instances (NoteOn, NoteOff, ControlChange, etc.)</li>
<li>Handle MIDI device disconnections and reconnections</li>
<li>Enumerate available MIDI ports</li>
</ul>
<p><strong>Event Flow</strong>:</p>
<pre><code>MIDI Device → midir callback → MidiEvent → mpsc channel
</code></pre>
<h3 id="gamepaddevicemanager"><a class="header" href="#gamepaddevicemanager">GamepadDeviceManager</a></h3>
<p><strong>Location</strong>: <code>conductor-daemon/src/gamepad_device.rs</code></p>
<p>Responsibilities:</p>
<ul>
<li>Poll HID game controllers via <code>gilrs</code> (v0.10)</li>
<li>Use SDL2-compatible controller mappings</li>
<li>Emit gilrs events (ButtonPressed, AxisChanged, etc.)</li>
<li>Handle gamepad disconnections and reconnections</li>
<li>Enumerate connected gamepads</li>
</ul>
<p><strong>Event Flow</strong>:</p>
<pre><code>Gamepad → gilrs::Gilrs::next_event() → gilrs::Event → gamepad_events → InputEvent → mpsc channel
</code></pre>
<h3 id="gilrs-integration"><a class="header" href="#gilrs-integration">gilrs Integration</a></h3>
<p>Conductor v3.0 uses <strong>gilrs v0.10</strong> for HID game controller support:</p>
<ul>
<li><strong>SDL2 Compatibility</strong>: Supports SDL_GameController mapping database</li>
<li><strong>Cross-Platform</strong>: Works on macOS, Linux, Windows</li>
<li><strong>Controller Support</strong>: Xbox, PlayStation, Nintendo Switch Pro, generic gamepads</li>
<li><strong>Polling Architecture</strong>: 1ms polling interval for low latency</li>
<li><strong>Event Types</strong>: ButtonPressed, ButtonReleased, AxisChanged, Connected, Disconnected</li>
</ul>
<h2 id="event-normalization"><a class="header" href="#event-normalization">Event Normalization</a></h2>
<h3 id="midi--inputevent-conversion"><a class="header" href="#midi--inputevent-conversion">MIDI → InputEvent Conversion</a></h3>
<p>The <code>convert_midi_to_input()</code> function maps MIDI protocol events to <code>InputEvent</code>:</p>
<pre><code class="language-rust">fn convert_midi_to_input(midi_event: MidiEvent) -&gt; InputEvent {
    match midi_event {
        MidiEvent::NoteOn { note, velocity, .. } =&gt;
            InputEvent::PadPressed { pad: note, velocity, time: now },

        MidiEvent::NoteOff { note, .. } =&gt;
            InputEvent::PadReleased { pad: note, time: now },

        MidiEvent::ControlChange { cc, value, .. } =&gt;
            InputEvent::EncoderTurned { encoder: cc, value, time: now },

        MidiEvent::Aftertouch { pressure, .. } =&gt;
            InputEvent::Aftertouch { pressure, time: now },

        MidiEvent::PitchBend { value, .. } =&gt;
            InputEvent::PitchBend { value, time: now },

        // ... other mappings
    }
}</code></pre>
<p><strong>Key Insight</strong>: This conversion happens in a spawned tokio task, allowing the MIDI device manager to remain protocol-agnostic while the InputManager handles unification.</p>
<h3 id="hid--inputevent-conversion"><a class="header" href="#hid--inputevent-conversion">HID → InputEvent Conversion</a></h3>
<p>The <code>gamepad_events</code> module provides three converter functions:</p>
<pre><code class="language-rust">// Button press: gilrs::Event → InputEvent::PadPressed
pub fn button_pressed_to_input(
    button: gilrs::Button,
    gamepad_id: gilrs::GamepadId
) -&gt; InputEvent {
    InputEvent::PadPressed {
        pad: button_to_id(button), // Maps to 128-144 range
        velocity: 100, // Default velocity for digital buttons
        time: Instant::now(),
    }
}

// Button release: gilrs::Event → InputEvent::PadReleased
pub fn button_released_to_input(
    button: gilrs::Button,
    gamepad_id: gilrs::GamepadId
) -&gt; InputEvent {
    InputEvent::PadReleased {
        pad: button_to_id(button),
        time: Instant::now(),
    }
}

// Analog axis: gilrs::Event → InputEvent::EncoderTurned
pub fn axis_changed_to_input(
    axis: gilrs::Axis,
    value: f32, // -1.0 to 1.0
    gamepad_id: gilrs::GamepadId
) -&gt; InputEvent {
    InputEvent::EncoderTurned {
        encoder: axis_to_encoder_id(axis), // Maps to 128-133 range
        value: normalize_axis_value(value), // Convert to 0-127
        time: Instant::now(),
    }
}</code></pre>
<h2 id="key-apis"><a class="header" href="#key-apis">Key APIs</a></h2>
<h3 id="creating-an-inputmanager"><a class="header" href="#creating-an-inputmanager">Creating an InputManager</a></h3>
<pre><code class="language-rust">use conductor_daemon::input_manager::{InputManager, InputMode};

// MIDI-only mode
let manager = InputManager::new(
    Some("Maschine Mikro MK3".to_string()),
    true, // auto_reconnect
    InputMode::MidiOnly
);

// Gamepad-only mode
let gamepad_manager = InputManager::new(
    None,
    true,
    InputMode::GamepadOnly
);

// Hybrid mode (both MIDI and gamepad)
let hybrid_manager = InputManager::new(
    Some("Maschine Mikro MK3".to_string()),
    true,
    InputMode::Both
);</code></pre>
<h3 id="connecting-to-devices"><a class="header" href="#connecting-to-devices">Connecting to Devices</a></h3>
<pre><code class="language-rust">use tokio::sync::mpsc;
use conductor_core::events::InputEvent;
use conductor_daemon::daemon::DaemonCommand;

let (event_tx, mut event_rx) = mpsc::channel::&lt;InputEvent&gt;(1024);
let (command_tx, mut command_rx) = mpsc::channel::&lt;DaemonCommand&gt;(32);

// Connect returns status message or error
match manager.connect(event_tx, command_tx) {
    Ok(status) =&gt; println!("Connected: {}", status),
    Err(e) =&gt; eprintln!("Connection failed: {}", e),
}

// Example output:
// "MIDI: Maschine Mikro MK3 (port 2) | Gamepad: Xbox 360 Controller (ID GamepadId(0))"</code></pre>
<h3 id="polling-events"><a class="header" href="#polling-events">Polling Events</a></h3>
<pre><code class="language-rust">// Process unified event stream
while let Some(event) = event_rx.recv().await {
    match event {
        InputEvent::PadPressed { pad, velocity, .. } =&gt; {
            if pad &lt; 128 {
                println!("MIDI pad {} pressed (vel: {})", pad, velocity);
            } else {
                println!("Gamepad button {} pressed", pad);
            }
        }
        InputEvent::EncoderTurned { encoder, value, .. } =&gt; {
            if encoder &lt; 128 {
                println!("MIDI CC {} = {}", encoder, value);
            } else {
                println!("Gamepad axis {} = {}", encoder, value);
            }
        }
        _ =&gt; {}
    }
}</code></pre>
<h3 id="enumerating-gamepads"><a class="header" href="#enumerating-gamepads">Enumerating Gamepads</a></h3>
<pre><code class="language-rust">// List all connected gamepads
match InputManager::list_gamepads() {
    Ok(gamepads) =&gt; {
        for (id, name, uuid) in gamepads {
            println!("Gamepad: {:?} - {} (UUID: {})", id, name, uuid);
        }
    }
    Err(e) =&gt; eprintln!("Failed to list gamepads: {}", e),
}

// Get gamepads managed by this InputManager
let connected = manager.get_connected_gamepads();
for (id, name) in connected {
    println!("Active: {} ({})", name, id);
}</code></pre>
<h3 id="checking-connection-status"><a class="header" href="#checking-connection-status">Checking Connection Status</a></h3>
<pre><code class="language-rust">// Check if any device is connected
if manager.is_connected() {
    println!("At least one device connected");
}

// Get detailed status
let (midi_connected, gamepad_connected) = manager.get_status();
println!("MIDI: {}, Gamepad: {}", midi_connected, gamepad_connected);</code></pre>
<h3 id="disconnecting"><a class="header" href="#disconnecting">Disconnecting</a></h3>
<pre><code class="language-rust">// Graceful shutdown of all devices
manager.disconnect();</code></pre>
<h2 id="hybrid-mode-architecture"><a class="header" href="#hybrid-mode-architecture">Hybrid Mode Architecture</a></h2>
<p>When using <code>InputMode::Both</code>, the InputManager creates both MIDI and gamepad device managers and merges their event streams:</p>
<pre><code>┌─────────────────────────────────────────────┐
│  InputManager::connect()                    │
│                                             │
│  1. Connect MIDI device                     │
│     - Create midi_event_rx channel          │
│     - Spawn converter task:                 │
│       while let Some(midi_evt) = rx.recv() {│
│         send(convert_midi_to_input(midi))   │
│       }                                     │
│                                             │
│  2. Connect Gamepad device                  │
│     - Directly sends InputEvent             │
│     - No conversion needed                  │
│                                             │
│  3. Both tasks send to same event_tx        │
│     - Unified mpsc::Sender&lt;InputEvent&gt;      │
│     - EventProcessor receives single stream │
└─────────────────────────────────────────────┘
</code></pre>
<h3 id="hybrid-mode-event-flow-example"><a class="header" href="#hybrid-mode-event-flow-example">Hybrid Mode Event Flow Example</a></h3>
<pre><code class="language-rust">// Time T0: MIDI note 60 pressed
InputEvent::PadPressed { pad: 60, velocity: 100, time: T0 }

// Time T1: Gamepad A button pressed (ID 128)
InputEvent::PadPressed { pad: 128, velocity: 100, time: T1 }

// Time T2: MIDI CC 7 changed
InputEvent::EncoderTurned { encoder: 7, value: 64, time: T2 }

// Time T3: Gamepad left stick X moved
InputEvent::EncoderTurned { encoder: 128, value: 90, time: T3 }</code></pre>
<p>All events flow through the same channel, preserving temporal ordering and enabling hybrid workflows like:</p>
<ul>
<li>MIDI pads for velocity-sensitive drumming</li>
<li>Gamepad sticks for smooth parameter sweeps</li>
<li>Gamepad buttons for mode switching</li>
<li>MIDI encoder for fine-grained control</li>
</ul>
<h2 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h2>
<p>The InputManager and its device managers use Rust's ownership system and Arc/Mutex patterns for safe concurrent access:</p>
<pre><code class="language-rust">pub struct InputManager {
    midi_manager: Option&lt;MidiDeviceManager&gt;,
    gamepad_manager: Option&lt;GamepadDeviceManager&gt;,
    mode: InputMode,
}

pub struct GamepadDeviceManager {
    gamepad_id: Arc&lt;Mutex&lt;Option&lt;gilrs::GamepadId&gt;&gt;&gt;,
    gamepad_name: Arc&lt;Mutex&lt;Option&lt;String&gt;&gt;&gt;,
    is_connected: Arc&lt;AtomicBool&gt;,
    stop_polling: Arc&lt;AtomicBool&gt;,
    polling_thread: Arc&lt;Mutex&lt;Option&lt;thread::JoinHandle&lt;()&gt;&gt;&gt;&gt;,
}</code></pre>
<h3 id="synchronization-mechanisms"><a class="header" href="#synchronization-mechanisms">Synchronization Mechanisms</a></h3>
<ul>
<li><strong>Arc&lt;Mutex<T>&gt;</strong>: Shared mutable state (gamepad ID, name, thread handles)</li>
<li><strong>Arc<AtomicBool></strong>: Lock-free connection status and stop flags</li>
<li><strong>mpsc channels</strong>: Lock-free event passing between threads</li>
<li><strong>tokio::spawn</strong>: Async task for MIDI conversion</li>
<li><strong>std::thread</strong>: Blocking thread for gamepad polling (gilrs is synchronous)</li>
</ul>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>The InputManager provides graceful degradation in hybrid mode:</p>
<pre><code class="language-rust">// In InputMode::Both:
match midi_mgr.connect(...) {
    Ok(_) =&gt; { /* MIDI connected */ },
    Err(e) =&gt; {
        warn!("Failed to connect MIDI (continuing with gamepad): {}", e);
        // Gamepad connection attempt continues
    }
}

match gamepad_mgr.connect(...) {
    Ok(_) =&gt; { /* Gamepad connected */ },
    Err(e) =&gt; {
        warn!("Failed to connect gamepad (continuing with MIDI): {}", e);
        // Return OK if MIDI connected
    }
}

// Only fail if BOTH connections failed
if status_messages.is_empty() {
    return Err("No input devices could be connected".to_string());
}</code></pre>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>MIDI</th><th>Gamepad</th><th>Hybrid</th></tr></thead><tbody>
<tr><td>Event Latency</td><td>&lt;1ms</td><td>&lt;2ms</td><td>&lt;2ms</td></tr>
<tr><td>Polling Rate</td><td>Callback-driven</td><td>1ms (1000Hz)</td><td>Both</td></tr>
<tr><td>CPU Usage (idle)</td><td>&lt;0.1%</td><td>&lt;0.5%</td><td>&lt;0.6%</td></tr>
<tr><td>Memory Overhead</td><td>~200KB</td><td>~1MB</td><td>~1.2MB</td></tr>
<tr><td>Thread Count</td><td>1 (callback)</td><td>1 (polling)</td><td>2</td></tr>
</tbody></table>
</div>
<h2 id="code-examples"><a class="header" href="#code-examples">Code Examples</a></h2>
<h3 id="example-1-midionly-mode"><a class="header" href="#example-1-midionly-mode">Example 1: MidiOnly Mode</a></h3>
<pre><code class="language-rust">use conductor_daemon::input_manager::{InputManager, InputMode};
use tokio::sync::mpsc;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let (event_tx, mut event_rx) = mpsc::channel(1024);
    let (command_tx, _) = mpsc::channel(32);

    let mut manager = InputManager::new(
        Some("Maschine Mikro MK3".to_string()),
        true,
        InputMode::MidiOnly
    );

    manager.connect(event_tx, command_tx)?;

    while let Some(event) = event_rx.recv().await {
        println!("MIDI Event: {:?}", event);
    }

    Ok(())
}</code></pre>
<h3 id="example-2-gamepadonly-mode"><a class="header" href="#example-2-gamepadonly-mode">Example 2: GamepadOnly Mode</a></h3>
<pre><code class="language-rust">use conductor_daemon::input_manager::{InputManager, InputMode};
use tokio::sync::mpsc;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let (event_tx, mut event_rx) = mpsc::channel(1024);
    let (command_tx, _) = mpsc::channel(32);

    let mut manager = InputManager::new(
        None, // No MIDI device
        true,
        InputMode::GamepadOnly
    );

    manager.connect(event_tx, command_tx)?;

    while let Some(event) = event_rx.recv().await {
        println!("Gamepad Event: {:?}", event);
    }

    Ok(())
}</code></pre>
<h3 id="example-3-hybrid-mode-both"><a class="header" href="#example-3-hybrid-mode-both">Example 3: Hybrid Mode (Both)</a></h3>
<pre><code class="language-rust">use conductor_daemon::input_manager::{InputManager, InputMode};
use conductor_core::events::InputEvent;
use tokio::sync::mpsc;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let (event_tx, mut event_rx) = mpsc::channel(1024);
    let (command_tx, _) = mpsc::channel(32);

    let mut manager = InputManager::new(
        Some("Maschine Mikro MK3".to_string()),
        true,
        InputMode::Both
    );

    let status = manager.connect(event_tx, command_tx)?;
    println!("Connected: {}", status);

    while let Some(event) = event_rx.recv().await {
        match event {
            InputEvent::PadPressed { pad, velocity, .. } =&gt; {
                if pad &lt; 128 {
                    println!("MIDI pad {} pressed (velocity: {})", pad, velocity);
                } else {
                    println!("Gamepad button {} pressed", pad - 128);
                }
            }
            InputEvent::EncoderTurned { encoder, value, .. } =&gt; {
                if encoder &lt; 128 {
                    println!("MIDI CC {} changed to {}", encoder, value);
                } else {
                    println!("Gamepad axis {} = {}", encoder - 128, value);
                }
            }
            _ =&gt; {}
        }
    }

    Ok(())
}</code></pre>
<h3 id="example-4-device-enumeration"><a class="header" href="#example-4-device-enumeration">Example 4: Device Enumeration</a></h3>
<pre><code class="language-rust">use conductor_daemon::input_manager::InputManager;

fn main() -&gt; Result&lt;(), String&gt; {
    // List all available gamepads
    println!("Available gamepads:");
    let gamepads = InputManager::list_gamepads()?;

    for (id, name, uuid) in gamepads {
        println!("  - {:?}: {} (UUID: {})", id, name, uuid);
    }

    Ok(())
}</code></pre>
<h2 id="integration-with-eventprocessor"><a class="header" href="#integration-with-eventprocessor">Integration with EventProcessor</a></h2>
<p>The InputManager produces <code>InputEvent</code> instances that flow directly into the <code>EventProcessor</code>:</p>
<pre><code class="language-rust">// conductor-core/src/event_processor.rs
impl EventProcessor {
    pub fn process(&amp;mut self, event: InputEvent) -&gt; Vec&lt;ProcessedEvent&gt; {
        match event {
            InputEvent::PadPressed { pad, velocity, time } =&gt; {
                // Detect velocity levels, long press, double-tap, chords
                self.process_pad_press(pad, velocity, time)
            }
            InputEvent::EncoderTurned { encoder, value, time } =&gt; {
                // Detect encoder direction, acceleration
                self.process_encoder(encoder, value, time)
            }
            // ... other event types
        }
    }
}</code></pre>
<p>The EventProcessor doesn't care if the event came from MIDI or a gamepad—it processes all <code>InputEvent</code> instances identically using the ID range to determine device type when needed.</p>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>The InputManager includes comprehensive unit tests:</p>
<pre><code class="language-bash"># Run InputManager tests
cargo test -p conductor-daemon input_manager

# Test specific mode creation
cargo test -p conductor-daemon test_input_manager_creation_midi_only
cargo test -p conductor-daemon test_input_manager_creation_gamepad_only
cargo test -p conductor-daemon test_input_manager_creation_both

# Test MIDI → InputEvent conversion
cargo test -p conductor-daemon test_convert_midi_note_on
cargo test -p conductor-daemon test_convert_midi_cc
</code></pre>
<h2 id="future-enhancements"><a class="header" href="#future-enhancements">Future Enhancements</a></h2>
<p>Potential future improvements to the InputManager:</p>
<ol>
<li><strong>Multiple Gamepad Support</strong>: Connect multiple gamepads simultaneously</li>
<li><strong>Device Prioritization</strong>: Configurable priority when events collide</li>
<li><strong>Custom ID Ranges</strong>: Allow users to remap ID ranges via config</li>
<li><strong>Hot-Swapping</strong>: Dynamic device addition/removal without restart</li>
<li><strong>Input Filtering</strong>: Filter specific buttons/axes before EventProcessor</li>
<li><strong>Virtual Devices</strong>: Create virtual MIDI/gamepad devices for testing</li>
</ol>
<h2 id="related-documentation"><a class="header" href="#related-documentation">Related Documentation</a></h2>
<ul>
<li><a href="../guides/gamepad-support.html">Gamepad Support Guide</a> - User-facing gamepad setup</li>
<li><a href="architecture.html">Architecture Overview</a> - Overall system architecture</li>
<li><a href="architecture.html#event-processing-pipeline">Event Processing Pipeline</a> - Event flow details</li>
<li><a href="../guides/device-templates.html">Device Templates Guide</a> - Pre-configured templates</li>
<li><a href="../configuration/overview.html">Configuration Reference</a> - Config file syntax</li>
</ul>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<p><strong>Game Controllers (HID)</strong>: The standard term used throughout Conductor documentation for HID input devices. This includes:</p>
<ul>
<li><strong>Gamepads</strong>: Xbox, PlayStation, Nintendo Switch Pro controllers (primary examples)</li>
<li><strong>Joysticks</strong>: Flight sticks, arcade sticks</li>
<li><strong>Racing Wheels</strong>: Steering wheel controllers</li>
<li><strong>HOTAS</strong>: Hands-On Throttle-And-Stick systems</li>
<li><strong>Custom Controllers</strong>: DIY Arduino-based controllers, specialized input devices</li>
</ul>
<p>All SDL2-compatible HID game controllers are supported via the gilrs library.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>The InputManager is a critical architectural component that:</p>
<ol>
<li><strong>Unifies</strong> MIDI and HID inputs into a single event stream</li>
<li><strong>Separates</strong> ID ranges to prevent conflicts (0-127 vs 128-255)</li>
<li><strong>Abstracts</strong> protocol differences behind <code>InputEvent</code></li>
<li><strong>Enables</strong> hybrid workflows with both MIDI and gamepad devices</li>
<li><strong>Provides</strong> flexible device selection via <code>InputMode</code></li>
</ol>
<p>This design allows Conductor to support a wide range of input devices while maintaining a clean, protocol-agnostic processing pipeline.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../development/architecture.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../development/plugin-development.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../development/architecture.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../development/plugin-development.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
